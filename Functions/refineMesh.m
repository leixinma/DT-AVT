% Create Mesh and Geometry
function [FEM] = refineMesh(nodes,elements,P,fd,region)
% About: Clean up, reorient, determine boundary properties, and increase 
% order of mesh generated by distmesh2D. Quadratures are also computed
%
% Author: Victor Singh
% Lab: MIT ACDL
% Contact: victorsi@mit.edu
% ///////////////////////////////////////////////////////////////////////// 

% Test and Reorientate Elements
eMid = 0;
n = size(elements,2);
for ii = 1:n
    eMid = eMid + nodes(elements(:,ii),:);
end
eMid = eMid/n;

% Calculate Orientations
theta = elements;
for ii = 1:n
    dx = nodes(elements(:,ii),:)-eMid;   
    p = eMid + 0.5*dx;
    theta(:,ii) = atan2(dx(:,2),dx(:,1));
end

% Sort in ascending angle
[~,ind] = sort(theta,2);

% Reorient elements
for ii = 1:size(elements,1)
    elements(ii,:) = elements(ii,ind(ii,:));  
end

% Find boundary nodes
r = 1e-3;
b = abs(fd(nodes))<=r; % distmesh distance function edge
bNodes = nodes(b,:);
% plot(bNodes(:,1),bNodes(:,2),'ok')

% Find faces on element boundary
Lie = ismember(elements,find(b));
indBE = find(sum(Lie,2)>1);
boundaryElements = elements(indBE,:);
Lie = Lie(indBE,:);
faces= [];
for ii = 1:size(boundaryElements,1)
    % Determine nodes of element on boundary
    elemTemp = boundaryElements(ii,[1:end,1]);
    LieTemp = Lie(ii,[1:end,1]);
    
    % Find boundary edge
    edges = LieTemp(1:end-1).*LieTemp(2:end)>0;
    points = [elemTemp(1:end-1);elemTemp(2:end)]';
    
    % Store faces
    faces = [faces;[indBE(ii)*ones(sum(edges),1),points(edges,:)]];
            
end

% Screen out internal elements (they show up as duplicated)
ind = sort(faces(:,2:end),2);
count = faces(:,1);
for ii = 1:size(faces,1) 
    count(ii) = sum(sum(abs(bsxfun(@plus,ind(ii,:),-ind)),2)==0);
end
faces(count>1,:) = [];

% Find face midpoints and normals
fMid = 0.5*(nodes(faces(:,2),:)+nodes(faces(:,3),:));
fNorm = (nodes(faces(:,3),:)-nodes(faces(:,2),:))*[0 -1;1 0];
fNorm = bsxfun(@times,fNorm,1./sqrt(sum(fNorm.^2,2)));

% Permute element nodes so that (1,0) edge is on boundary
for ii = 1:size(faces,1)
    % Get Nodes
    nds = elements(faces(ii,1),:);
    ids = find(nds==faces(ii,2));
    nds = [nds(ids),nds((ids+1):end),nds(1:(ids-1))];
    elements(faces(ii,1),:) = nds;
    
end

% Store Preliminary
FM.nodes = nodes;
FEM.order = P;
FM.order = P;
FM.elements= elements;
FM.boundary.elements = faces;

% Loop through types
% Plate
Oo = max(FEM.order.plate(1),FEM.order.parameter(1)); % In-plane quadrature depends on max of inplane orders
F = setOrder(FM,FEM.order.plate(1));
FEM.plate.nodes = F.nodes;
FEM.plate.elements = F.elements;
FEM.plate.boundary = F.boundary;
FEM.plate.planarElem = buildBasis('Triangle',FEM.order.plate(1),Oo);
FEM.plate.boundaryElem = buildBasis('Line',FEM.order.plate(1),Oo);
FEM.plate.thicknessElem = buildBasis('Line',FEM.order.plate(2),FEM.order.plate(2));

% Parameter
F = setOrder(FM,FEM.order.parameter(1));
FEM.parameter.nodes = F.nodes;
FEM.parameter.elements = F.elements;
FEM.parameter.boundary = [];
FEM.parameter.planarElem = buildBasis('Triangle',FEM.order.parameter(1),Oo);
FEM.parameter.thicknessElem = buildBasis('Line',FEM.order.parameter(2),FEM.order.plate(2));

% Determine boundary nodes
edges = [];
nodesBoundary = unique(reshape(FEM.plate.boundary.elements(:,2:end),[],1));

for ii = 1:size(region.curves,2)
    % Compute points on curves
    c = region.curves(ii);
    t = linspace(0,0.9999,5000)';
    ut =  region.mappingC(t,c.x,c.mapping.param);
    
    % Get Nodal Points
    un = FEM.plate.nodes(nodesBoundary,:);
    
    % Find a starting t closest to each un
    d = sqrt((ut(:,1)' - un(:,1)).^2 + (ut(:,2)' - un(:,2)).^2);
    [d,id] = min(d,[],2);
    
    % Screen
    ind = d < 0.5e-2;
    id = id(ind);
    
    % Get Nodes and Starting t
    to = t(id);
    No = nodesBoundary(ind);
    
    % Refine using newton iteration
    t = to;
    for jj = 1:1:10
        % Compute Distance Formula
        un = FEM.plate.nodes(No,:);
        [ut,dut,d2ut] = region.mappingC(t,c.x,c.mapping.param);
        
        % Compute Derivatives
        dr = 2*(ut(:,1) - un(:,1)).*dut(:,1) + 2*(ut(:,2) - un(:,2)).*dut(:,2);
        d2r =  2*dut(:,1).*dut(:,1) + 2*(ut(:,1) - un(:,1)).*d2ut(:,1) + ...
               2*dut(:,2).*dut(:,2) + 2*(ut(:,2) - un(:,2)).*d2ut(:,2) + ...
               2*(ut(:,1) - un(:,1)).*dut(:,1) + 2*(ut(:,2) - un(:,2)).*dut(:,2);
        
        % Update
        t = t - (dr./d2r);
    end
    
    % Assign lower bound as zero
    T = t;
    [~,ind] = min(T);
    T(ind) = 0;
    
    % Store
    edges = [edges;[ii+No*0,No,T]];
end
FEM.plate.boundary.edges = edges;

% Compute t and c values for plate boundary on nodes
M = FEM.plate;
boundary = M.boundary;
T = ones(size(M.nodes,1),1);
C = T*0;
X = M.nodes(boundary.elements(:,2:end),1);
Y = M.nodes(boundary.elements(:,2:end),2);
T(boundary.edges(:,2)) = boundary.edges(:,3);
C(boundary.edges(:,2)) = boundary.edges(:,1);
T = reshape(T(boundary.elements(:,2:end)),size(boundary.elements(:,2:end)));
C = reshape(C(boundary.elements(:,2:end)),size(boundary.elements(:,2:end)));
X = reshape(X,size(boundary.elements(:,2:end)));
Y = reshape(Y,size(boundary.elements(:,2:end)));

% Enforce dual values of starting and end nodes for
% cyclic boundaries
inde = T(:,end) == 0 & T(:,end-1) > 0.5;
ind1 = T(:,1) == 0 & T(:,2) > 0.5;
T(inde,end) = 1;
T(ind1,1) = 1;

% Store
FEM.plate.boundary.T = T;
FEM.plate.boundary.C = C;
FEM.plate.boundary.X(:,:,1) = X;
FEM.plate.boundary.X(:,:,2) = Y;

end

% Get Shape basis functions
function basisFunction = buildBasis(type,O,Oo)
[q,w] = quadratureRule(type,Oo);
[N,dN,param] = basisFunctions(type,q,O);
basisFunction.type = type;
basisFunction.w = w;
basisFunction.q = q;
basisFunction.N = N;
basisFunction.dN = dN;
basisFunction.param = param;

end

% Get basis function coordinates
function Pi = getCoordinates(N)
% Build Nodes in Local Basis
T = tril(ones(N+1));
x = repmat(linspace(0,1,N+1),N+1,1);
y = flipud(x');
X = T.*x;
Y = T.*y;
P = unique([X(:),Y(:)],'rows');

% Get Index of Element Vertices
[~,~,iv] = intersect([0 0;1 0;0 1],P,'rows','stable');

% Reorder Nodes (First Vertices (CCW), then X sort, then Y sort)
Pi = P;
Pi(iv,:)= [];
Pi = [P(iv,:);sortrows(Pi)];
end

% Order Refinement
function FEM = setOrder(FEM,N)
% Get Local Basis Coordinates
Pi = getCoordinates(N);

% Build New Nodes
Nn = size(Pi,1)-3;
nElem = size(FEM.elements,1);
Nbasis = [1-sum(Pi,2),Pi(:,1),Pi(:,2)];
newNx = zeros(nElem*Nn,size(FEM.nodes,2));
for ii = 1:nElem
    % Get Element Node Positions
    nodes = FEM.elements(ii,:);
    nX = FEM.nodes(nodes,:);
    
    % Construct Nodal Positions
    x = Nbasis*nX;
    
    % Store New Positions
    newNx((ii-1)*Nn + (1:Nn),:) = x(4:end,:);
    
end

% Find Unique Nodes
[un,ia,ic] = unique(round(newNx*1e5),'rows');

% Assign index to new nodes
indN = [1:size(un,1)]'+size(FEM.nodes,1);

% Add new nodes to elements
ic = reshape(ic,Nn,[])';
FEM.elements = [FEM.elements,indN(ic)];
FEM.nodes = [FEM.nodes;newNx(ia,:)];

% Update FEM Boundaries with New Nodes
Nb = size(FEM.boundary.elements,1);
Boundary = zeros(Nb,N+1);
for ii = 1:Nb
    % Get Nodes on Boundary
    nodesB = FEM.boundary.elements(ii,:);
    
    % Get Nodes of Element
    nodesE = FEM.elements(nodesB(1),:);
        
    % Find collinear components 
    u = [-1 1]*FEM.nodes(nodesB(2:3),:);
    v = bsxfun(@plus,FEM.nodes(nodesE,:),-FEM.nodes(nodesB(2),:));
    un = u/norm(u);
    vn = bsxfun(@times,v,1./(sqrt(sum(v.^2,2))));
    uv = vn*un';
    ci = abs(uv-1)<=1e-3 | isnan(uv);

    % Sort in Ascending
    nodesE = nodesE(ci);
    [~,ci] = sort(v(ci,:)*un');
    
    % Store Nodes
    Boundary(ii,:) = nodesE(ci);
    
end
FEM.boundary.elements = [FEM.boundary.elements(:,1),Boundary];

end

% Basis functions and quadrature weights
function [qP,qW] = quadratureRule(bType,O)

switch bType
    case 'Triangle'
        % Rows correspond to points. Columns are coordinates
        [qP,qW] = simplexquad(O+1,[0 0;0 1;1 0]);
        
    case 'Line'
        % Rows correspond to points. Columns are coordinates
        [qP,qW] = simplexquad(O+1,[-1;1]);
        
end

end

function [N,dN,param] = basisFunctions(bType,qP,O)
% Build Basis Functions using Fundamental Relations
% Get Basis Function Order
switch bType
    case 'Triangle'
        % Get Nodal Coordinates
        P = getCoordinates(O);
   
    case 'Line'
        % Get Nodal Coordinates - Gauss Labotto for high order
        x = 0:O;
        P = sort(cos(pi*x'/O)); 
        
end

% Build Basis and Basis Function Gradients
K = interpolator(P,O,P);
Kinv = K\eye(size(P,1));

% Compute K
[k,dk] = interpolator(qP,O,P);
N = k*Kinv;
for ii = size(dk,3):-1:1
    dN(:,:,ii) = dk(:,:,ii)*Kinv;
end

% Store param
param.Kinv = Kinv;
param.P = P;
param.order = O;
param.type = bType;

end
